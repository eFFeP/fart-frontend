
require('dotenv').config();
const express = require('express');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const cors = require('cors');
const jwt = require('jsonwebtoken');
const sgMail = require('@sendgrid/mail');
const rateLimit = require("express-rate-limit");

const app = express();
app.use(cors());
app.use(express.json());

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  ssl: { rejectUnauthorized: false }
});

const JWT_SECRET = process.env.JWT_SECRET || 'your_jwt_secret';

sgMail.setApiKey(process.env.SENDGRID_API_KEY);

const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) return res.sendStatus(401);

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user;
    next();
  });
};

const isAdmin = (req, res, next) => {
  if (req.user && (req.user.role === 'admin' || req.user.role === 'superadmin')) {
    next();
  } else {
    res.status(403).json({ error: 'Accesso non autorizzato' });
  }
};

const isSuperAdmin = (req, res, next) => {
  if (req.user && req.user.role === 'superadmin') {
    next();
  } else {
    res.status(403).json({ error: 'Accesso non autorizzato' });
  }
};

const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100
});

app.use(apiLimiter);

// Rotta di login
app.post('/login', async (req, res) => {
  const { email, password } = req.body;
  try {
    const result = await pool.query('SELECT * FROM users WHERE email = $1', [email]);
    if (result.rows.length > 0) {
      const user = result.rows[0];
      const isValidPassword = await bcrypt.compare(password, user.password);
      if (isValidPassword) {
        const token = jwt.sign(
          { userId: user.id, email: user.email, role: user.role },
          JWT_SECRET,
          { expiresIn: '24h' }
        );
        res.json({ 
          message: 'Login effettuato con successo',
          token,
          userId: user.id,
          username: user.username,
          role: user.role,
          isFirstLogin: user.is_first_login
        });
      } else {
        res.status(401).json({ error: 'Credenziali non valide' });
      }
    } else {
      res.status(401).json({ error: 'Credenziali non valide' });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore durante il login' });
  }
});

// Rotte per la gestione degli utenti
app.get('/admin/users', authenticateToken, isAdmin, async (req, res) => {
  try {
    let query = 'SELECT * FROM users';
    if (req.user.role !== 'superadmin') {
      query += ' WHERE role != \'superadmin\'';
    }
    const result = await pool.query(query);
    res.json(result.rows);
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore nel recupero degli utenti' });
  }
});

app.get('/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const result = await pool.query('SELECT * FROM users WHERE id = $1', [id]);
    if (result.rows.length > 0) {
      const user = result.rows[0];
      delete user.password;
      res.json(user);
    } else {
      res.status(404).json({ error: 'Utente non trovato' });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore nel recupero delle informazioni dell\'utente' });
  }
});

app.post('/admin/users', authenticateToken, isAdmin, async (req, res) => {
  const { username, email, password, nome, cognome, ditta, settore, deposito, funzione, matricola, dataNascita, telefono, role } = req.body;
  try {
    const hashedPassword = await bcrypt.hash(password, 10);
    const result = await pool.query(
      'INSERT INTO users (username, email, password, nome, cognome, ditta, settore, deposito, funzione, matricola, data_nascita, telefono, role, is_first_login) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14) RETURNING id',
      [username, email, hashedPassword, nome, cognome, ditta, settore, deposito, funzione, matricola, dataNascita, telefono, role, true]
    );
    res.status(201).json({ message: 'Utente creato con successo', id: result.rows[0].id });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore durante la creazione dell\'utente' });
  }
});

app.put('/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
  const { id } = req.params;
  const { username, email, nome, cognome, ditta, settore, deposito, funzione, matricola, dataNascita, telefono, role } = req.body;
  try {
    const result = await pool.query(
      'UPDATE users SET username = $1, email = $2, nome = $3, cognome = $4, ditta = $5, settore = $6, deposito = $7, funzione = $8, matricola = $9, data_nascita = $10, telefono = $11, role = $12 WHERE id = $13 RETURNING *',
      [username, email, nome, cognome, ditta, settore, deposito, funzione, matricola, dataNascita, telefono, role, id]
    );
    if (result.rows.length > 0) {
      res.json(result.rows[0]);
    } else {
      res.status(404).json({ error: 'Utente non trovato' });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore nella modifica dell\'utente' });
  }
});

app.delete('/admin/users/:id', authenticateToken, isAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const result = await pool.query('DELETE FROM users WHERE id = $1 RETURNING id', [id]);
    if (result.rows.length > 0) {
      res.json({ message: 'Utente eliminato con successo' });
    } else {
      res.status(404).json({ error: 'Utente non trovato' });
    }
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore nell\'eliminazione dell\'utente' });
  }
});

// Rotte per la gestione delle password
app.post('/admin/users/:id/reset-password', authenticateToken, isAdmin, async (req, res) => {
  const { id } = req.params;
  try {
    const user = await pool.query('SELECT email FROM users WHERE id = $1', [id]);
    if (user.rows.length === 0) {
      return res.status(404).json({ error: 'Utente non trovato' });
    }

    const resetToken = jwt.sign({ userId: id }, JWT_SECRET, { expiresIn: '1h' });
    const resetLink = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;

    const msg = {
      to: user.rows[0].email,
      from: process.env.SENDGRID_FROM_EMAIL,
      subject: 'Reset Password',
      text: `Clicca sul seguente link per resettare la tua password: ${resetLink}`,
      html: `<p>Clicca sul seguente link per resettare la tua password: <a href="${resetLink}">Reset Password</a></p>`,
    };

    await sgMail.send(msg);
    await pool.query('UPDATE users SET reset_token = $1, is_first_login = true WHERE id = $2', [resetToken, id]);

    res.json({ message: 'Email per il reset della password inviata con successo' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore nell\'invio dell\'email per il reset della password' });
  }
});

app.post('/forgot-password', async (req, res) => {
  const { email } = req.body;
  try {
    const user = await pool.query('SELECT id FROM users WHERE email = $1', [email]);
    if (user.rows.length === 0) {
      return res.json({ message: 'Se l\'email esiste, riceverai istruzioni per il reset della password.' });
    }

    const resetToken = jwt.sign({ userId: user.rows[0].id }, JWT_SECRET, { expiresIn: '1h' });
    const resetLink = `${process.env.FRONTEND_URL}/reset-password?token=${resetToken}`;

    const msg = {
      to: email,
      from: process.env.SENDGRID_FROM_EMAIL,
      subject: 'Reset Password',
      text: `Clicca sul seguente link per resettare la tua password: ${resetLink}`,
      html: `<p>Clicca sul seguente link per resettare la tua password: <a href="${resetLink}">Reset Password</a></p>`,
    };

    await sgMail.send(msg);
    await pool.query('UPDATE users SET reset_token = $1 WHERE id = $2', [resetToken, user.rows[0].id]);

    res.json({ message: 'Se l\'email esiste, riceverai istruzioni per il reset della password.' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore nell\'invio dell\'email per il reset della password' });
  }
});

// Rotte per la gestione dei gruppi beta
app.post('/admin/users/:userId/beta', authenticateToken, isAdmin, async (req, res) => {
  const { userId } = req.params;
  const { group, isChecked } = req.body;
  
  try {
    const updateField = group === 'beta1' ? 'beta1' : 'beta2';
    await pool.query(
      `UPDATE users SET ${updateField} = $1 WHERE id = $2`,
      [isChecked, userId]
    );
    res.json({ message: 'Gruppo beta aggiornato con successo' });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Errore nell\'aggiornamento del gruppo beta' });
  }
});

// ... [Il resto del codice rimane invariato] ...

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
